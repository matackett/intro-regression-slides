<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Simple Linear Regression</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr.Â Maria Tackett" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">





class: title-slide 

&lt;br&gt;&lt;br&gt;

# Simple Linear Regression 
## Theory

&lt;br&gt;&lt;br&gt;&lt;br&gt;

### Dr. Maria Tackett

---

## Topics 

--


  
--







---

### General form of model

.alert[
`$$Y = f(\mathbf{X}) + \epsilon$$`
]

- `\(Y\)`: quantitative response variable

- `\(\mathbf{X} = (X_1, X_2, \ldots, X_p)\)`: predictor variables

- `\(f\)`: fixed but unknown function
    - systematic information `\(\mathbf{X}\)` provides about `\(Y\)`

- `\(\epsilon\)`: random error term with mean 0 that is independent of `\(\mathbf{X}\)` 
   
---

### How to estimate `\(f\)`?

In general, we will use the following steps to estimate `\(f\)`

- Choose the functional form of `\(f\)`, i.e. &lt;font class="vocab"&gt;choose the appropriate model given the data&lt;/font&gt;
    - Ex: `\(f\)` is a linear model
    `$$f(\mathbf{X}) = \beta_0 + \beta_1 X_1 + \dots + \beta_p X_p + \epsilon$$`
&lt;br&gt; 

--

- Use the data to fit the model, i.e. &lt;font class="vocab"&gt;estimate the model parameters&lt;/font&gt;
    - Ex: Use a method to estimate the model parameters `\(\beta_0, \beta_1, \ldots, \beta_p\)`

---

### Why estimate `\(f\)`?

Suppose we have the model

`$$\text{audience} = \beta_0 + \beta_1 \times \text{critics} + \epsilon$$`
&lt;br&gt;&lt;br&gt;

--

.question[

- What is one question you can answer using this model?

- Submit your response at: http://bit.ly/sta210-sp20-q

- Use **NetId@duke.edu** for your email address.

- You are welcome (and encouraged!) to discuss these questions with 1 - 2 people around you, but **each person** must submit a response.
]

<div class="countdown blink-colon noupdate-5" id="timer_5f060441" style="right:0;bottom:0;" data-warnwhen="30">
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


---

### Why estimate `\(f\)`?

There are two types of questions we may wish to answer using our model:

- &lt;font class="vocab"&gt;Prediction: &lt;/font&gt; What is the expected `\(Y\)`  given particular values of  `\(X_1, X_2, \ldots, X_p\)`? 
--

    - Ex: What is the expected audience score for a movie that receives a critic score of 70%? 

--

- &lt;font class="vocab"&gt;Inference: &lt;/font&gt; What is the relationship between `\(\mathbf{X}\)` and `\(Y\)`. How does `\(Y\)` change as a function of `\(\mathbf{X}\)`?
--

    - Ex: How much can we expect the audience score to change for each additional point in the critic score?

---

### Course Outline

- **Unit 1: Quantitative Response Variables**
    - Simple Linear Regression 
    - Multiple Linear Regression

&lt;br&gt;

- **Unit 2: Categorical Response Variable**
    - Logistic Regression 
    - Multinomial Logistic Regression 

&lt;br&gt;

- **Unit 3: Looking Ahead**
    - Log-linear models
    - Weighted least squares
    - Missing data
    - Special topics 

---

class: middle, center

### Simple Linear Regression

---

### Least-Squares Regression

- There is some true relationship between `\(X\)` and `\(Y\)` that exists in the population

`$$Y = f(X) + \epsilon$$`

--

- If `\(f\)` is approximated by a linear function, then we can write the relationship as 

`$$Y = \beta_0 + \beta_1 X + \epsilon$$` 

--

- We'll estimate the slope and intercept of this linear function using &lt;font class = "vocab"&gt;least-squares regression&lt;/font&gt;

--

- We'll use statistical inference to determine if the relationship we observe in the data is statistically significant or if it's due to random chance (we'll talk about this more next class)

---

### Regression Model 

`$$Y|X \sim N(\beta_0 + \beta_1 X,\sigma^2)$$`

&lt;img src="img/regression.png" width="80%" style="display: block; margin: auto;" /&gt;

- `\(\sigma\)`: the standard deviation of `\(Y\)` as a function of `\(X\)` 

- **&lt;i&gt;Assumption&lt;/i&gt;:** `\(\sigma\)` is equal for all values of `\(X\)`

---

### Regression Model

.alert[
`$$Y|X \sim N(\beta_0 + \beta_1 X, \sigma^2)$$`
]

--

- For a single observation `\((x_i, y_i)\)`

`$$y_i = \beta_0 + \beta_1 x_i + \epsilon_i \hspace{10mm} \epsilon_i \sim N(0,\sigma^2)$$`
&lt;br&gt;&lt;br&gt;
--

- We want to use the `\(n\)` observations `\((x_1,y_1), \ldots, (x_n, y_n)\)` to estimate `\(\beta_0\)` and `\(\beta_1\)`. We will use *least-squares regression* estimates.

---

### Residuals

&lt;img src="slr-theory_files/figure-html/unnamed-chunk-4-1.png" style="display: block; margin: auto;" /&gt;

The .vocab[residual] is the difference between the observed and predicted response.

---

### Residual Sum of Squares

- The residual for the `\(i^{th}\)` observation is 

`$$e_i = y_i - \hat{y}_i =  y_i - (\hat{\beta}_0 + \hat{\beta}_1 x_i)$$`

--

- The *residual sum of squares* is 

`$$RSS = e^2_1 + e^2_2 + \dots + e^2_n$$`

--


- The .vocab[least-squares regression] approach chooses coefficients `\(\hat{\beta}_0\)` and `\(\hat{\beta}_1\)` to minimize RSS.

---

### Estimating Coefficients

- .vocab[Slope:]

`$$\hat\beta_1 = \frac{\sum\limits_{i=1}^n(x_i-\bar{x})(y_i - \bar{y})}{\sum\limits_{i=1}^n(x_i-\bar{x})^2} = r\frac{s_y}{s_x}$$`
such that `\(r\)` is the correlation between `\(x\)` And `\(y\)`.
&lt;br&gt;&lt;br&gt;

- .vocab[Intercept:] `\(\hat{\beta}_0 = \bar{y} - \hat{\beta}_1\bar{x}\)`

&lt;br&gt;&lt;br&gt;
*Optional: [Deriving the Least-Squares Estimates for Simple Linear Regression](https://github.com/sta210-sp20/supplemental-notes/blob/master/slr-derivations.pdf)*

---

## Confidence interval for `\(\beta_1\)`

.eq[
`$$\Large{\hat{\beta}_1 \pm t^* SE(\hat{\beta}_1)}}$$`
]

- `\(t^*\)` is the critical value associated with the confidence level.
  + It is calculated from a `\(t\)` distribution with `\(n-2\)` degrees of freedom
  
- `\(SE(\hat{\beta}_1)\)` is the standard error for the slope 

`$$SE(\hat{\beta}_1) = \sqrt{\frac{\hat{\sigma}^2}{\sum\limits_{i=1}^n (x_i - \bar{x})^2}} \hspace{2.5mm} = \hspace{2.5mm} \hat{\sigma}\sqrt{\frac{1}{(n-1)s_X^2}}$$`

---

### What is `\(\hat{\sigma}\)`?

- Recall, the residual is the difference between the observed response the predicted response (the estimated mean) 
    - The residual for the ith observation, `\((x_i, y_i)\)`, is
    
    `$$e_i = y_i - (\hat{\beta}_0 + \hat{\beta}_1 x_i)$$` 

- The &lt;font class = "vocab"&gt;Residual Standard Error&lt;/font&gt; is the estimate of variation about the regression line
    - Also known as the **Root Mean Square Error (RMSE)**

.alert[
`$$\hat{\sigma} = \sqrt{\frac{1}{n-2}\sum\limits_{i=1}^{n} e_i^2}$$`
]
---

### Why *t*? 

.alert[
`$$\hat{\beta}_1 \sim N \Bigg(\beta_1, \sigma\sqrt{\frac{1}{(n-1)s_X^2}} \Bigg)$$`
]

- We don't know `\(\sigma\)`, so we use its estimate `\(\hat{\sigma}\)` in our calculations. Therefore, we use the *t* distribution when we calculate the confidence interval (and conduct hypothesis tests) to account for the extra variability that's been introduced (same reason we use *t* when doing inference for a mean)

- The critical value `\(t^*\)` is calculated from the *t(n-2)* distribution - the *t* distribution with *n-2* degrees of freedom.


---

## Recap
--


--
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "4:3",
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
