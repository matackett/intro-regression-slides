---
title: "Simple Linear Regression"
subtitle: "Foundation"
author: "Dr. Maria Tackett"
output:
  xaringan::moon_reader:
    mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: "slides.css"
    logo: "img/introregression-sticker.png"
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: 4:3
      slideNumberFormat: "%current%"
    seal: false #make custom title slide
editor_options: 
  chunk_output_type: console
---

```{r child = "setup.Rmd"}
```

class: title-slide 

<br><br>

# Simple Linear Regression 
## Foundation

<br><br><br>

### Dr. Maria Tackett

---

## Topics 

--


  
--



```{r packages, echo = F}
library(tidyverse)
library(broom)
library(knitr)
library(kableExtra)
library(patchwork)
library(fivethirtyeight)
```

```{r data}
movie_scores <- fandango %>%
  rename(critics = rottentomatoes, 
         audience = rottentomatoes_user)
```

---

## General form of model

.alert[
$$Y = f(X) + \epsilon$$
]

$Y$: response variable

--

$X$: predictor variables

--

$f$: fixed but unknown function

--

$\epsilon$: random error
   
---

## In simple linear regression

.eq[
$$\begin{aligned} Y &= \color{purple}{\textbf{Model}} + \text{Error} \\[8pt]
&= \color{purple}{f(X)} + \epsilon \\[8pt]
&= \color{purple}{\mu_{Y|X}} + \epsilon \\[8pt]
&= \color{purple}{\beta_0 + \beta_1 X} + \epsilon \end{aligned} $$
]

---

## Regression Model 

$$Y|X \sim N(\beta_0 + \beta_1 X,\sigma^2)$$

```{r, echo=FALSE,out.width = '80%',fig.align='center'}
knitr::include_graphics("img/regression.png")
```

$\sigma$: the standard deviation of $Y$ as a function of $X$ 

---

## Regression Model 

```{r}
##   Code from https://stackoverflow.com/questions/31794876/ggplot2-how-to-curve-small-gaussian-densities-on-a-regression-line?rq=1

## pulled from broadening your statistical horizons
set.seed(0)
dat <- data.frame(x=(x=runif(10000, 0, 50)),
                  y=rnorm(10000, 10*x, 100))
## breaks: where you want to compute densities
breaks <- seq(0, max(dat$x), len=5)
dat$section <- cut(dat$x, breaks)
## Get the residuals
dat$res <- residuals(lm(y ~ x, data=dat))
## Compute densities for each section, flip the axes, add means of sections
## Note: densities need to be scaled in relation to section size (2000 here)
dens <- do.call(rbind, lapply(split(dat, dat$section), function(x) {
  d <- density(x$res, n=5000)
  res <- data.frame(x=max(x$x)- d$y*2000, y=d$x+mean(x$y))
  res <- res[order(res$y), ]
  ## Get some data for normal lines as well
  xs <- seq(min(x$res), max(x$res), len=5000)
  res <- rbind(res, data.frame(y=xs + mean(x$y),
                               x=max(x$x) - 2000*dnorm(xs, 0, sd(x$res))))
  res$type <- rep(c("empirical", "normal"), each=5000)
  res
}))
dens$section <- rep(levels(dat$section), each=10000)
ggplot(dat, aes(x, y)) +
  geom_point(size = 0.1) +
  geom_smooth(method="lm", fill=NA, lwd=2) +
  geom_path(data=dens[dens$type=="normal",], aes(x, y, group=section), 
            color="salmon", lwd=1.1) +
  theme_bw() +
  geom_vline(xintercept=breaks, lty=2)
```

### Regression Model

.alert[
$$Y|X \sim N(\beta_0 + \beta_1 X, \sigma^2)$$
]

--

- For a single observation $(x_i, y_i)$

$$y_i = \beta_0 + \beta_1 x_i + \epsilon_i \hspace{10mm} \epsilon_i \sim N(0,\sigma^2)$$
<br><br>

---

## Recap
--


--


